Проблема: Внутренняя обработка EVP_PKEY в OpenSSL
Когда вы создаете EVP_PKEY в bign_keymgm_to_evp_pkey и заполняете его с помощью EVP_PKEY_paramgen и EVP_PKEY_set_params , вы создаете EVP_PKEY, который выглядит как ключ EC. Однако встроенный в OpenSSL i2d_PrivateKey (который часто вызывается неявно, когда происходит универсальная кодировка, такая как genpkey -outform DER) в первую очередь ожидает ключи, которые были либо:

Загружается из стандартных структур ASN.1 (например, PKCS # 8).
Генерируется внутри с помощью встроенного в OpenSSL EC key management.
Ваш ключ BIGN генерируется вашим провайдером, а затем преобразуется в EVP_PKEY. 
Хотя EVP_PKEY_set_params - это правильный способ установить ключевые компоненты в объект EVP_PKEY ,
похоже, что i2d_PrivateKey по умолчанию (который является частью основного уровня OpenSSL EVP, 
а не вашего провайдера) не знает, 
как сериализовать EVP_PKEY, который получен от провайдера и имеет пользовательские внутренние компоненты.


Решение: Правильно реализуйте OSL_FUNC_KEYMGMT_EXPORT и OSL_FUNC_ENCODER_ENCODE для ВАШЕГО типа ключа
Вы пытаетесь использовать i2d_PrivateKey внутри osl_bign_encoder_der_encode. 
Но сам i2d_PrivateKey выходит из строя (или, скорее, OpenSSL не удается подготовить EVP_PKEY для 
i2d_PrivateKey еще до запуска вашей функции).

Вместо того, чтобы полагаться на i2d_PrivateKey (это общая функция, которая может не понимать 
детали ключа для конкретного поставщика), вам необходимо самостоятельно реализовать фактическую 
кодировку DER вашего ключа BIGN в osl_bign_encoder_der_encode.

Это означает, что вы вручную создадите структуру ASN.1 для закрытого ключа BIGN. 
Поскольку BIGN представляет собой криптосистему с эллиптической кривой, весьма вероятно,
что формат ее закрытого ключа будет соответствовать стандарту PKCS # 8 для закрытых ключей, 
который обертывает ключевые данные, специфичные для алгоритма.
НЕ используйте i2d_PrivateKey.
Вместо этого напрямую преобразуйте ваш BIGN_KEYMGMT_KEY (в частности, key-> priv_key и key-> group) в правильную структуру ASN.1 DER для закрытого ключа BIGN.
Это будет включать функции построения ASN.1 в OpenSSL (например, ASN1_SEQUENCE_new, ASN1_INTEGER_new, ASN1_OCTET_STRING_new, i2d_ASN1_SEQUENCE и т.д.), Или, если в OpenSSL есть определенные структуры закрытых ключей EC, вы должны использовать их (EC_KEY_new, EC_KEY_set_group, EC_KEY_set_private_key , затем i2d_ECPrivateKey ).
Учитывая, что BIGN - это алгоритм, подобный EC, вы могли бы использовать стандартные структуры ключей EC OpenSSL (например, EC_KEY).

Попробуйте этот подход в bign_keymgm_to_evp_pkey, а затем используйте i2d_ECPrivateKey в osl_bign_encoder_der_encode:


==========================
Когда ossl_bign_keymgmt_gen возвращает BIGN_KEYMGMT_KEY*, 
основная библиотека OpenSSL принимает этот указатель и сохраняет его в объекте EVP_PKEY. 
В частности, он присваивает его полю pkey->keymgmt_data .
Итак, если приложение вызывает EVP_PKEY_generate_init(), а затем EVP_PKEY_generate() 
для вашего типа ключа BIGN , оно в конечном итоге получает EVP_PKEY *, 
где фактический материал ключа (ваш BIGN_KEYMGMT_KEY) спрятан внутри pkey->keymgmt_data .
============================
Функция bign_keymgm_to_evp_pkey, которую мы обсуждали ранее, действует как мост преобразования. 
Его цель - взять ваш BIGN_KEYMGMT_KEY * (который вы только что успешно сгенерировали) и
создать стандартный EVP_PKEY *, который содержит EC_KEY * внутри. Затем этот EVP_PKEY * 
подходит для универсальных кодеров PKCS8 и PEM OpenSSL.
Приложение генерирует ключ: вызывает EVP_PKEY_CTX_new_id(NID_bign_curveXYZ, NULL),
EVP_PKEY_generate_init(), EVP_PKEY_generate().
Ваш провайдер генерирует ключ: OpenSSL отправляет вашей функции osl_bign_keymgmt_gen, 
которая создает и возвращает BIGN_KEYMGMT_KEY*.
У приложения есть EVP_KEY: у приложения теперь есть EVP_KEY*, где pkey-> keymgmt_data указывает 
на ваш BIGN_KEYMGMT_KEY*.
Приложение хочет закодировать PKCS #8: вызывает PEM_write_bio_PKCS8PrivateKey(bio, pkey, ...) 
или EVP_PKEY_asn1_to_pkcs8_private_bio(bio, pkey).
OpenSSL нуждается в стандартном EVP_PKEY_EC: Внутренне этим функциям кодирования требуется EVP_PKEY,
который распознается как стандартный EVP_PKEY_EC (содержащий EC_KEY).
Вызывается ваш bign_keymgm_to_evp_pkey: именно здесь вы должны вызвать свой bign_keymgm_to_evp_pkey
(как часть процесса экспорта / преобразования ключа, если приложение явно запрашивает это, или, возможно, 
даже внутренне, если для этого настроена отправка вашего кодировщика).


функция bign_keymgt_to_evp_key, которую мы доработали ранее (та, которая использует ваш osl_bign_keymgt_export для построения osl_params, а затем вызывает EVP_PKEY_fromdata), является именно тем компонентом, который позволяет преобразовать ваш BIGN_KEYMGT_KEY в формат, понятный общим кодировщикам PKCS # 8.

Итак, функция генерации ключа (osl_bign_keymgmt_gen) предоставляет внутренние данные, а функция bign_keymgm_to_evp_pkey (используемая вашим кодировщиком) преобразует эти внутренние данные в форму, используемую стандартными процедурами кодирования OpenSSL.

Ваш osl_bign_keymgmt_gen, похоже, правильно реализован для своей цели. Теперь основное внимание должно оставаться на том, чтобы убедиться, что ваш кодировщик правильно вызывает bign_keymgm_to_evp_key (или аналогичную логику), чтобы преобразовать ваш BIGN_KEYMGMT_KEY в EVP_KEY для сериализации PKCS # 8.

Вы хотите еще раз перепроверить функции bign_keymgm_to_evp_pkey и encoder, чтобы убедиться, что они правильно интегрируются с этим сгенерированным key_ctx?

Хорошо, давайте резюмируем ключевые моменты, а затем вы можете сказать мне, хотите ли вы сосредоточиться на каких-то конкретных областях:

Генерация ключа (osl_bign_keymgmt_gen): Эта функция отвечает за генерацию вашего ключа BIGN и сохранение его в структуре BIGN_KEYMGMT_KEY. Вы подтвердили, что эта функция работает правильно. Она создает закрытый ключ (priv_key), открытый ключ (pub_key) и устанавливает группу EC (group).

Преобразование ключа (bign_keymgm_to_evp_pkey): Эта функция принимает ваш BIGN_KEYMGMT_KEY и преобразует его в стандартный EVP_PKEY, понятный универсальным функциям OpenSSL. Последняя версия этой функции использует вашу функцию osl_bign_keymgmt_export для получения ключевых параметров в виде osl_params, а затем использует EVP_PKEY_fromdata для построения EVP_PKEY. Это имеет решающее значение для совместимости с кодерами PKCS #8.

Кодировка PKCS #8 (osl_bign_encoder_der_encode и osl_bign_encoder_pem_encode): Эти функции принимают EVP_PKEY, созданный bign_keymgm_to_evp_pkey, и используют EVP_PKEY_asn1_to_pkcs8_private_bio (для DER) или PEM_write_bio_PKCS8PrivateKey (для PEM) для генерации выходных данных PKCS#8.